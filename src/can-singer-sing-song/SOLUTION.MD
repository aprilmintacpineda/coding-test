To solve this problem, one must first realize that the values of the Notes are dynamic and changes based on its siblings! That is to say that B1, while being a really high note, C2 would be higher! The logic responsible for this is the **Octave**. A note is composed of 2 things, the **Pitch (lowest - C D E F G A B - highest)** and the **Octave 0 1 2 3 4 5 6 7**. The octave is primarily the determiner if a note is higher than another note. In the case above where C2 is higher than B1, the reason is because C2 has an octave of 2 and B1 only have an octave of 1. In cases where 2 notes have the same octave, such as B1 and C1, you need to compare the place value (that means we need to assign numbers to pitch from 0 or C to 6 or B) of their pitch to determine which one is higher, in this case B1 is higher than C1 because B (6) has higher place value than C (0).

So your function will have the following signature: `singable (song: Note[], lowestNoteSingerCanSing: Note, highestNoteSingerCanSing: Note) => boolean`. Given an array of note, what you really just need to do is find the highest note in the song and the lowest note in the song by comparing each notes to other notes using the logic I described above. Once you have found the highest and lowest note in the song, you just need to make sure that the lowest note in the song is not lower than the singer's lowest note **AND** the highest note in the song is not higher than the singer's highest note, if this check fails then you need to `return false`, otherwise, `return true`.
